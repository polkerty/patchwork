<html>

<head>
    <title>Experimental commitfest patch ranker</title>
    <script src="https://code.jquery.com/jquery-3.7.1.slim.js"
        integrity="sha256-UgvvN8vBkgO0luPSUl2s8TIlOSYRoGFAX4jlCIm9Adc=" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/simple-datatables@latest/dist/style.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest" type="text/javascript"></script>
</head>

<body>

    <div id="main">
        <h1>03/2025 Commitfest patch ranker (experimental)</h1>
        <p>How it works: LLM reads through mailing list threads to figure out the status, and we cross-reference the
            files changed to the ones you've changed historically to create a custom ranking of relevant patches
            for anyone who's committed to Postgres in the past, or been credited as a <code>Author:</code>.
        </p>
        <div id="controls">
            <h2>Loading...</h2>
        </div>
        <div id="content">
        </div>
        <div id="table">
            <div id="table_inner">

            </div>

        </div>

    </div>


    <script defer>

        const DATA = {};
        const STATE = {};

        function setContributor(event) {
            STATE.contributor = event.target.value;
            renderContent();
        }

        function renderControls() {
            let html = '';

            html += `
                    <select onChange="setContributor(event)" >
                        <option>Select your name...</option>
                        ${STATE.contributors.map(c => `<option value="${c}">${c}</option>`)}
                    </select>
                    `;

            $('#controls').html(html);
        }

        function getPatchData() {
            // Prepare a list of patches for the currently-selected contributor, 
            // ranked according to their best match.

            // 1. get all patches
            let patches = DATA.patches.map(x => ({ ...x }));

            const rankings =
                Object.fromEntries(
                    DATA.rankings.
                        filter(x => x.reviewer === STATE.contributor).
                        map(x => ({ ...x })).
                        map(x => [x.patch, x])
                );

            // 2. decorate
            for (const patch of patches) {
                patch.rankData = rankings[patch.patch_id];
                patch.rank = rankings[patch.patch_id]?.rank ?? patches.length;
                patch.commitfest = { ...STATE.patchById[patch.patch_id] };
                patch.threads = STATE.threadsOfPatch[patch.patch_id].map(thread => STATE.byThread[thread]);

                // hoisting some thread data up for each of use in the table
                patch.newReviewer = patch.threads.map(t => t.would_benefit_from_new_reviewer).filter(v => v === 'YES').length > 0
                    ? 'Yes'
                    : 'No';

                // dummy IDs to work around table not allowing multiple references to the same column
                // never mind, this is a nightmare, i'll have to redo it in react. wtf.
                patch.patch_id_2 = patch.patch_id;
                patch.patch_id_3 = patch.patch_id;
            }

            patches = patches.sort((a, b) => a.rank < b.rank ? -1 : 1);

            return patches;
        }

        function renderContent() {
            let html = '';

            if (!STATE.contributor) {
                html = '<h2>Please select your name to see your personalized patch review recommendations</h2>';
                $("#content").html(html);
                return;
            }

            // Patch list
            const patchData = getPatchData();

            // for testing
            console.log(patchData);
            console.log(patchData[0]);

            STATE.table = patchData;

            $('#table').html("<div id='table_inner' ></div>"); // reset to appease table library

            let dataTable = new window.simpleDatatables.DataTable('#table_inner', {
                searchable: true,
                fixedHeight: true,
                columns: [
                    {
                        select: 0,
                    },
                    {
                        select: 1,
                        render: renderNameLink,
                        searchMethod: (terms, cell, row, _column, source) => {
                            if (!terms.length) return true;
                            // this is painful but we have to work backwards again to get the name
                            const entry = STATE.patchById[cell.data[0].data]; // forgive me, it's a demo
                            const lower_case = entry.name.toLowerCase();
                            return terms.filter(term => lower_case.includes(term.toLowerCase())).length === terms.length;
                        }
                    },
                    {
                        // relevancy ...
                        select: 3,
                        sort: "asc"
                    },
                    {
                        select: 4,
                        render: renderThreads,
                    }

                ],
                data: {
                    headings: [
                        {
                            text: "ID",
                            data: "patch_id"
                        },
                        {
                            text: "Name",
                            data: 'patch_id_2',
                        },
                        {
                            text: "[LLM] Would benefit from a net-new reviewer?",
                            data: "newReviewer"
                        },
                        {
                            text: "Relevancy rank",
                            data: "rank",
                        },
                        {
                            text: "Threads",
                            data: "patch_id_3"
                        },
                    ],
                    data: patchData
                }


            });

            $("#content").html(html);
        }

        const renderNameLink = function (data, cell, dataIndex, cellIndex) {
            const entry = STATE.patchById[data[0].data]; // forgive me, it's a demo
            cell.childNodes = [

                {
                    nodeName: "SPAN",
                    attributes: {
                        "style": `display: none;`,
                    },
                    childNodes: [
                        {
                            nodeName: "#text",
                            data: entry.name // fix sort
                        }
                    ],

                },
                {
                    nodeName: "A",
                    attributes: {
                        "href": `https://commitfest.postgresql.org/patch/${entry.patch_id}/`,
                        "target": "_blank"
                    },
                    childNodes: [
                        {
                            nodeName: "#text",
                            data: entry.name
                        }
                    ]
                }
            ]
        }

        const renderThreads = function (data, cell, dataIndex, cellIndex) {
            const entry = STATE.patchById[data[0].data]; // forgive me, it's a demo
            const threads = STATE.threadsOfPatch[entry.id].map(thread => STATE.byThread[thread]);
            cell.childNodes = [{
                nodeName: "DIV",
                childNodes: threads.flatMap(thread =>
                ([
                    {
                        nodeName: "A",
                        attributes: {
                            "href": `https://postgr.es/m/${thread.id}/`,
                            "target": "_blank"
                        },
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: "Link to thread"
                            }
                        ]
                    },
                    {
                        nodeName: "BR"
                    },
                    {
                        nodeName: "STRONG",
                        attributes: {
                            style: "margin-right: 10px;"
                        },
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: "[LLM] Thread status"  
                            }
                        ]
                    },                    
                    {
                        nodeName: "SPAN",
                        attributes: {
                        },
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: thread.status
                            }
                        ]
                    },
                    {
                        nodeName: "BR"
                    },
                    {
                        nodeName: "STRONG",
                        attributes: {
                            style: "margin-right: 10px;"
                        },
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: "[LLM] Activity"  
                            }
                        ]
                    },                    
                    {
                        nodeName: "SPAN",
                        attributes: {
                        },
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: thread.activity
                            }
                        ]
                    },                    
                    {
                        nodeName: "BR"
                    },
                    {
                        nodeName: "STRONG",
                        attributes: {
                            style: "margin-right: 10px;"
                        },
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: "Last message:"  
                            }
                        ]
                    },                    
                    {
                        nodeName: "SPAN",
                        attributes: {
                        },
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: thread.stats.last_activity
                            }
                        ]
                    },                    // {
                    //     nodeName: "SPAN",
                    //     attributes: {
                    //         "style": "color: green; margin: 0px 5px;"
                    //     },
                    //     childNodes: [
                    //         {
                    //             nodeName: "#text",
                    //             data: "+" 
                    //         }
                    //     ]
                    // },
                    {
                        nodeName: "BR"
                    },
                    {
                        nodeName: "STRONG",
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: "[LLM] Summary: "
                            }

                        ]

                    },
                    {
                        nodeName: "SPAN",
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: thread.summary
                            }

                        ]

                    },
                    {
                        nodeName: "BR"
                    },
                    {
                        nodeName: "STRONG",
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: "Main Issue: "
                            }

                        ]

                    },
                    {
                        nodeName: "SPAN",
                        childNodes: [
                            {
                                nodeName: "#text",
                                data: thread.problem
                            }

                        ]

                    }
                ]))
            }]
        }

        function render() {
            renderControls();
            renderContent();
        }

        function constructLookups() {
            // Various indexes to make certain things more efficient.
            const patchById = {};
            for (const patch of DATA.patches) {
                patchById[patch.patch_id] = patch;
            }

            const threadsOfPatch = {};
            for (const { patch, message } of DATA.patchMessage) {
                if (!threadsOfPatch[patch]) {
                    threadsOfPatch[patch] = [];
                }
                threadsOfPatch[patch].push(message);
            }

            const byThread = {};
            for (const thread of DATA.threadSummaries) {
                byThread[thread.id] = thread;
            }
            for (const thread of DATA.threadStats) {
                if (!byThread[thread.message_id]) {
                    // whoops...
                    console.log("No summary for thread: " + thread.message_id);
                    continue;
                }
                byThread[thread.message_id].stats = thread;
            }

            return {
                patchById,
                threadsOfPatch,
                byThread
            }
        }

        (async () => {
            // 1. Fetch principal data sources
            const dataBaseURL = 'data/';
            const [
                threadSummaries,
                rankings,
                patches,
                threadStats,
                patchMessage
            ] = await Promise.all([
                'thread_summaries.json',
                'contrib_tf_idf.json',
                'patches.json',
                'thread_stats.json',
                'patch_message.json',

            ].map(url => fetch(dataBaseURL + url).then(x => x.json())))

            Object.assign(DATA, {
                threadSummaries,
                rankings,
                patches,
                threadStats,
                patchMessage
            });

            Object.assign(STATE, constructLookups());

            STATE.contributors = [... new Set(DATA.rankings.map(x => x.reviewer))];


            // 2. Set up UX
            render();

            setContributor({ target: { value: 'Robert Haas' } }); // for testing only

        })();
    </script>
</body>

</html>