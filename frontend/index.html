<html>

<head>
    <title>Experimental commitfest patch ranker</title>
    <script src="https://code.jquery.com/jquery-3.7.1.slim.js"
        integrity="sha256-UgvvN8vBkgO0luPSUl2s8TIlOSYRoGFAX4jlCIm9Adc=" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/simple-datatables@latest/dist/style.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest" type="text/javascript"></script>
</head>

<body>

    <div id="main">
        <h1>Commitfest patch ranker (experimental)</h1>
        <p>How it works: LLM reads through mailing list threads to figure out the status, and we cross-reference the 
            files changed to the ones you've changed historically to create a custom ranking of relevant patches
            for anyone who's committed to Postgres in the past, or been created as a <code>Author:</code>. 
        </p>
        <div id="controls">
            <h2>Loading...</h2>
        </div>
        <div id="content">
        </div>
        <div id="table">

        </div>

    </div>


    <script defer>

        const DATA = {};
        const STATE = {};

        function setContributor(event) {
            STATE.contributor = event.target.value;
            renderContent();
        }

        function renderControls() {
            let html = '';

            html += `
                    <select onChange="setContributor(event)" >
                        <option>Select your name...</option>
                        ${STATE.contributors.map(c => `<option value="${c}">${c}</option>`)}
                    </select>
                    `;

            $('#controls').html(html);
        }

        function getPatchData() {
            // Prepare a list of patches for the currently-selected contributor, 
            // ranked according to their best match.

            // 1. get all patches
            const patches = DATA.patches.map(x => ({...x}));

            const rankings = 
                Object.fromEntries(
                    DATA.rankings.
                        filter(x => x.reviewer === STATE.contributor).
                        sort((a, b) => b.sum - a.sum).
                        map(x => ({ ...x })).
                        map(x => [x.patch, x])
        );

            // 2. decorate
            for (const patch of patches) {
                patch.rankData = rankings[patch.patch_id];
                patch.rank = rankings[patch.patch_id]?.rank ?? patches.length; 
                patch.commitfest = { ...STATE.patchById[patch.patch_id] };
                patch.threads = STATE.threadsOfPatch[patch.patch_id].map(thread => STATE.byThread[thread]);
            }


            return patches;
        }

        function renderContent() {
            let html = '';

            if (!STATE.contributor) {
                html = '<h2>Please select your name to see your personalized patch review recommendations</h2>';
                $("#content").html(html);
                return;
            }

            // Patch list
            const patchData = getPatchData();

            // for testing
            console.log(patchData);
            console.log(patchData[0]);

            STATE.table = patchData; 
            
            let dataTable = new window.simpleDatatables.DataTable('#table', {
                searchable: true,
                fixedHeight: true,
                columns: [
                    {
                        select: 1,
                        render: renderNameLink,
                    },
                    {
                        // relevancy ...
                        select: 2,
                        sort: "asc"
                    }
                ],
                data: {
                    headings: [
                        {
                            text: "ID",
                            data: "patch_id"
                        }, 
                        {
                            text: "Name",
                            data: 'name',
                        }, 
                        {
                            text: "Relevancy rank",
                            data: "rank",
                        }, 
                        // {
                        //     text: "Threads",
                        //     data: "threads"
                        // }, 
                    ],
                    data: patchData
                }


            });

            $("#content").html(html);
        }

        const renderNameLink = function(data, cell, dataIndex, cellIndex) {
            const entry = STATE.table[dataIndex];
            cell.childNodes = [{
                nodeName: "A",
                attributes: {
                    "href": `https://commitfest.postgresql.org/patch/${entry.patch_id}/`,
                    "target": "_blank"
                },
                childNodes: [
                    {
                        nodeName: "#text",
                        data: entry.name
                    }
                ]
            }]
        }

        function render() {
            renderControls();
            renderContent();
        }

        function constructLookups() {
            // Various indexes to make certain things more efficient.
            const patchById = {};
            for (const patch of DATA.patches) {
                patchById[patch.patch_id] = patch;
            }


            const threadsOfPatch = {};
            for (const { patch, message } of DATA.patchMessage) {
                if (!threadsOfPatch[patch]) {
                    threadsOfPatch[patch] = [];
                }
                threadsOfPatch[patch].push(message);
            }

            const byThread = {};
            for (const thread of DATA.threadSummaries) {
                byThread[thread.id] = thread;
            }
            for (const thread of DATA.threadStats) {
                if (!byThread[thread.message_id]) {
                    // whoops...
                    console.log("No summary for thread: " + thread.message_id);
                    continue;
                }
                byThread[thread.message_id].stats = thread;
            }

            return {
                patchById,
                threadsOfPatch,
                byThread
            }
        }

        (async () => {
            // 1. Fetch principal data sources
            const dataBaseURL = 'data/';
            const [
                threadSummaries,
                rankings,
                patches,
                threadStats,
                patchMessage
            ] = await Promise.all([
                'thread_summaries.json',
                'contrib_tf_idf.json',
                'patches.json',
                'thread_stats.json',
                'patch_message.json',

            ].map(url => fetch(dataBaseURL + url).then(x => x.json())))

            Object.assign(DATA, {
                threadSummaries,
                rankings,
                patches,
                threadStats,
                patchMessage
            });

            Object.assign(STATE, constructLookups());

            STATE.contributors = [... new Set(DATA.rankings.map(x => x.reviewer))];


            // 2. Set up UX
            render();

            setContributor({ target: { value: 'Robert Haas' } }); // for testing only

        })();
    </script>
</body>

</html>