<html>

<head>
    <title>Experimental commitfest patch ranker</title>
    <script src="https://code.jquery.com/jquery-3.7.1.slim.js"
        integrity="sha256-UgvvN8vBkgO0luPSUl2s8TIlOSYRoGFAX4jlCIm9Adc=" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/simple-datatables@latest/dist/style.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest" type="text/javascript"></script>
</head>

<body>

    <div id="main">
        <div id="controls">
            <h2>Loading...</h2>
        </div>
        <div id="content">
        </div>
        <div id="table">

        </div>

    </div>


    <script defer>

        const DATA = {};
        const STATE = {};

        function setContributor(event) {
            STATE.contributor = event.target.value;
            renderContent();
        }

        function renderControls() {
            let html = '';

            html += `
                    <select onChange="setContributor(event)" >
                        <option>Select your name...</option>
                        ${STATE.contributors.map(c => `<option value="${c}">${c}</option>`)}
                    </select>
                    `;

            $('#controls').html(html);
        }

        function getPatchData() {
            // Prepare a list of patches for the currently-selected contributor, 
            // ranked according to their best match.

            // 1. get list
            const patches = DATA.rankings.filter(x => x.reviewer === STATE.contributor).sort((a, b) => b.sum - a.sum).map(x => ({ ...x }));

            // 2. decorate with message threads; this is a fresh clone
            for (const patch of patches) {
                patch.commitfest = { ...STATE.patchById[patch.patch] };
                patch.threads = STATE.threadsOfPatch[patch.patch].map(thread => STATE.byThread[thread]);
            }


            return patches;
        }

        function renderContent() {
            let html = '';

            if (!STATE.contributor) {
                html = '<h2>Please select your name to see your personalized patch review recommendations</h2>';
                $("#content").html(html);
                return;
            }

            // Patch list
            const patchData = getPatchData();

            // for testing
            console.log(patchData);
            console.log(patchData[0]);
            
            let dataTable = new window.simpleDatatables.DataTable('#table', {
                searchable: true,
                fixedHeight: true,
                // columns: [
                //     // {
                //     //     // select the fourth column ...
                //     //     select: 3,
                //     //     // ... let the instance know we have datetimes in it ...
                //     //     type: "date",
                //     //     // ... pass the correct datetime format ...
                //     //     format: "YYYY/DD/MM",
                //     //     // ... sort it ...
                //     //     sort: "desc"
                //     // }
                // ],
                data: {
                    headings: [
                        {
                            text: "ID",
                            data: "patch"
                        }, 
                    ],
                    data: patchData
                }


            });

            $("#content").html(html);
        }

        function render() {
            renderControls();
            renderContent();
        }

        function constructLookups() {
            // Various indexes to make certain things more efficient.
            const patchById = {};
            for (const patch of DATA.patches) {
                patchById[patch.patch_id] = patch;
            }


            const threadsOfPatch = {};
            for (const { patch, message } of DATA.patchMessage) {
                if (!threadsOfPatch[patch]) {
                    threadsOfPatch[patch] = [];
                }
                threadsOfPatch[patch].push(message);
            }

            const byThread = {};
            for (const thread of DATA.threadSummaries) {
                byThread[thread.id] = thread;
            }
            for (const thread of DATA.threadStats) {
                if (!byThread[thread.message_id]) {
                    // whoops...
                    console.log("No summary for thread: " + thread.message_id);
                    continue;
                }
                byThread[thread.message_id].stats = thread;
            }

            return {
                patchById,
                threadsOfPatch,
                byThread
            }
        }

        (async () => {
            // 1. Fetch principal data sources
            const dataBaseURL = 'data/';
            const [
                threadSummaries,
                rankings,
                patches,
                threadStats,
                patchMessage
            ] = await Promise.all([
                'thread_summaries.json',
                'contrib_tf_idf.json',
                'patches.json',
                'thread_stats.json',
                'patch_message.json',

            ].map(url => fetch(dataBaseURL + url).then(x => x.json())))

            Object.assign(DATA, {
                threadSummaries,
                rankings,
                patches,
                threadStats,
                patchMessage
            });

            Object.assign(STATE, constructLookups());

            STATE.contributors = [... new Set(DATA.rankings.map(x => x.reviewer))];


            // 2. Set up UX
            render();

            setContributor({ target: { value: 'Robert Haas' } }); // for testing only

        })();
    </script>
</body>

</html>